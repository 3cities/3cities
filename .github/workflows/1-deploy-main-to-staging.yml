# TODO actions/prod-build
# TODO actions/prod-test-build
# TODO always check out the created tag for the build so we're not checking out main branch which might have been async updated
name: 1 | Deploy main to staging
on:
  push:
    branches:
      - main
jobs:
  verify-build:
    name: Verify build
    runs-on: ubuntu-latest
    outputs:
      commit_hash: ${{ steps.get_commit.outputs.hash }}
    steps:
      - uses: 3cities/checkout@f095bcc56b7c2baf48f3ac70d6d6782f4f553222
        with:
          ref: main
      - uses: ./.github/actions/verify-build
      - id: get_commit
        run: echo "hash=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
  tag:
    needs: [verify-build] # tag iff build verification successful to avoid tagging a broken build
    if: ${{ needs.verify-build.outputs.commit_hash != null }}
    name: GitHub tag
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.github-tag-action.outputs.new_tag }}
      changelog: ${{ steps.github-tag-action.outputs.changelog }}
    steps:
      - uses: 3cities/checkout@f095bcc56b7c2baf48f3ac70d6d6782f4f553222
        with:
          ref: ${{ needs.verify-build.outputs.commit_hash }}
      - name: Bump prerelease version and push tag
        id: github-tag-action
        uses: 3cities/github-tag-action@86a7b93c90a7fb79fca2911075262fb781c9136a
        with:
          pre_release_branches: ${{ needs.verify-build.outputs.commit_hash }}
  deploy-staging:
    needs: [verify-build, tag]
    if: ${{ needs.tag.outputs.new_tag != null }}
    name: Deploy staging
    runs-on: ubuntu-latest
    steps:
      - uses: 3cities/checkout@f095bcc56b7c2baf48f3ac70d6d6782f4f553222
        with:
          ref: ${{ needs.verify-build.outputs.commit_hash }}
      - uses: ./.github/actions/setup
      - run: yarn build:prod-test # ie. our staging deployment is a production build with test dependencies
        env:
          # WARNING staging uses test dependencies, so we must ensure that that the env vars below are correctly set to test values where applicable (eg. a wallet provider's API key should be the test value to avoid using mainnet wallets in staging, but rpc provider prod values should be used because the app will automatically use only testnet chains)
          REACT_APP_GIT_TAG: ${{ needs.tag.outputs.new_tag }}
          REACT_APP_ALCHEMY_API_KEY: ${{ secrets.REACT_APP_ALCHEMY_API_KEY }}
          REACT_APP_INFURA_API_KEY: ${{ secrets.REACT_APP_INFURA_API_KEY }}
          REACT_APP_WEB3AUTH_CLIENT_ID: ${{ secrets.REACT_APP_WEB3AUTH_CLIENT_ID_STAGING }}
          REACT_APP_WALLETCONNECT_PROJECT_ID: ${{ secrets.REACT_APP_WALLETCONNECT_PROJECT_ID_STAGING }}
      # - run: touch ./packages/react-app/build/static/fake-source.map # uncomment this to test source map detection and trigger a workflow failure
      - run: (find ./packages/react-app/build | grep "map$" || exit 0 && (echo "unexpectedly found a source map in the build directory, failing build" && exit 1);) # sanity check to ensure sourcemaps are disabled in deployments to avoid leaking our web src
      - name: Update Cloudflare Pages deployment
        uses: 3cities/pages-action@fec3b22b824c5f29546e2d28cf3027db72d050ec
        with:
          apiToken: ${{ secrets.CLOUDFLARE_PAGES_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: 3cities-staging
          directory: packages/react-app/build
          githubToken: ${{ secrets.GITHUB_TOKEN }}
          branch: main # Cloudflare Pages will mark this deployment as 'Preview' because we're building from a HEAD commit unless we pass it a branch name it considers to be a production branch, and that branch is configured as "main".
  deploy-staging-prod:
    needs: [verify-build, tag]
    if: ${{ needs.tag.outputs.new_tag != null }}
    name: Deploy staging-prod
    runs-on: ubuntu-latest
    steps:
      - uses: 3cities/checkout@f095bcc56b7c2baf48f3ac70d6d6782f4f553222
        with:
          ref: ${{ needs.verify-build.outputs.commit_hash }}
      - uses: ./.github/actions/setup
      - run: yarn build # ie. our staging-prod deployment is an ordinary production build
        env:
          REACT_APP_GIT_TAG: ${{ needs.tag.outputs.new_tag }}
          REACT_APP_ALCHEMY_API_KEY: ${{ secrets.REACT_APP_ALCHEMY_API_KEY }}
          REACT_APP_INFURA_API_KEY: ${{ secrets.REACT_APP_INFURA_API_KEY }}
          REACT_APP_WEB3AUTH_CLIENT_ID: ${{ secrets.REACT_APP_WEB3AUTH_CLIENT_ID }}
          REACT_APP_WALLETCONNECT_PROJECT_ID: ${{ secrets.REACT_APP_WALLETCONNECT_PROJECT_ID }}
      # - run: touch ./packages/react-app/build/static/fake-source.map # uncomment this to test source map detection and trigger a workflow failure
      - run: (find ./packages/react-app/build | grep "map$" || exit 0 && (echo "unexpectedly found a source map in the build directory, failing build" && exit 1);) # sanity check to ensure sourcemaps are disabled in deployments to avoid leaking our web src
      - name: Update Cloudflare Pages deployment
        uses: 3cities/pages-action@fec3b22b824c5f29546e2d28cf3027db72d050ec
        with:
          apiToken: ${{ secrets.CLOUDFLARE_PAGES_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: 3cities-staging-prod
          directory: packages/react-app/build
          githubToken: ${{ secrets.GITHUB_TOKEN }}
          branch: main # Cloudflare Pages will mark this deployment as 'Preview' because we're building from a HEAD commit unless we pass it a branch name it considers to be a production branch, and that branch is configured as "main".
  push-to-releases-staging:
    needs: [verify-build, deploy-staging, deploy-staging-prod]
    name: 'Push to releases/staging'
    runs-on: ubuntu-latest
    steps:
      - uses: 3cities/checkout@f095bcc56b7c2baf48f3ac70d6d6782f4f553222
        with:
          ref: ${{ needs.verify-build.outputs.commit_hash }}
          fetch-depth: 0 # fetch all tags/history, required for the push below to succeed as it must locally compare against releases/staging to execute the non-fast-forward push.
      - name: Git push
        # NB we use default of fast-forward only (no force push) because we want our CI/CD pipeline to have linear history for safety. This is also enforced in releases/staging protected branch settings.
        run: |
          git push origin ${{ needs.verify-build.outputs.commit_hash }}:refs/heads/releases/staging
  github-prerelease:
    needs: [verify-build, tag, deploy-staging, deploy-staging-prod]
    name: GitHub pre-release
    runs-on: ubuntu-latest
    steps:
      - uses: 3cities/checkout@f095bcc56b7c2baf48f3ac70d6d6782f4f553222
        with:
          ref: ${{ needs.verify-build.outputs.commit_hash }}
          fetch-depth: 0 # fetch all tags/history, required for release-action to find new_tag.
      - name: Create GitHub pre-release
        uses: 3cities/release-action@eb05307dcee34deaad054e98128088a30d7980dc
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          prerelease: true
          artifacts: false # include no zip files of source code
          tag: ${{ needs.tag.outputs.new_tag }}
          name: Pre-release ${{ needs.tag.outputs.new_tag }}
          body: |            
            ${{ needs.tag.outputs.changelog }}
  staging-deployment-successful: # no-op job to force a workflow-level "staging-deployment-successful" github status check to be published. Github automatically makes the result of each workflow job available as a status check.
    needs: [push-to-releases-staging, github-prerelease]
    name: Success status
    runs-on: ubuntu-latest
    steps:
      - run: exit 0 # no-op because a job definition requires something to do, but all we want this job to do is publish a workflow-level github status check.
