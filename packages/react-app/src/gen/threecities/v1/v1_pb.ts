// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file threecities/v1/v1.proto (package threecities.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * LogicalAssetTicker is the set of all logical asset tickers we
 * support. Our app-layer LogicalAssetTicker types are automatically
 * derived from this single authoritative definition in a typesafe
 * manner.
 *
 * @generated from enum threecities.v1.LogicalAssetTicker
 */
export enum LogicalAssetTicker {
  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_ETH = 1;
   */
  ETH = 1,

  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_USD = 2;
   */
  USD = 2,

  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_EUR = 3;
   */
  EUR = 3,

  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_CAD = 4;
   */
  CAD = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(LogicalAssetTicker)
proto3.util.setEnumType(LogicalAssetTicker, "threecities.v1.LogicalAssetTicker", [
  { no: 0, name: "LOGICAL_ASSET_TICKER_UNSPECIFIED" },
  { no: 1, name: "LOGICAL_ASSET_TICKER_ETH" },
  { no: 2, name: "LOGICAL_ASSET_TICKER_USD" },
  { no: 3, name: "LOGICAL_ASSET_TICKER_EUR" },
  { no: 4, name: "LOGICAL_ASSET_TICKER_CAD" },
]);

/**
 * CheckoutSettings is a flattened variant of our app-layer type
 * CheckoutSettings. This CheckoutSettings has been flattened into a
 * single type (ie. instead of using separate types for proposedPayment,
 * etc) to help minimize binary serialization message size.
 *
 * @generated from message threecities.v1.CheckoutSettings
 */
export class CheckoutSettings extends Message<CheckoutSettings> {
  /**
   * required.
   *
   * @generated from oneof threecities.v1.CheckoutSettings.proposed_payment_receiver
   */
  proposedPaymentReceiver: {
    /**
     * Big-endian binary encoding of Ethereum address of the payment receiver. Deserialized as CheckoutSettings.proposedPayment.receiver.address
     *
     * @generated from field: bytes proposed_payment_receiver_address = 1;
     */
    value: Uint8Array;
    case: "proposedPaymentReceiverAddress";
  } | {
    /**
     * ENS name of the payment receiver. Deserialized as CheckoutSettings.proposedPayment.receiver.ensName
     *
     * @generated from field: string proposed_payment_receiver_ens_name = 2;
     */
    value: string;
    case: "proposedPaymentReceiverEnsName";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * required. Ticker for logical asset in which payment is denominated. Deserialized as CheckoutSettings.proposedPayment.logicalAssetTicker
   *
   * @generated from field: threecities.v1.LogicalAssetTicker proposed_payment_logical_asset_ticker = 3;
   */
  proposedPaymentLogicalAssetTicker = LogicalAssetTicker.UNSPECIFIED;

  /**
   * required.
   *
   * @generated from oneof threecities.v1.CheckoutSettings.proposed_payment_payment_mode
   */
  proposedPaymentPaymentMode: {
    /**
     * Big-endian binary encoding of payment logical asset amount. Deserialized as CheckoutSettings.proposedPayment.paymentMode.logicalAssetAmountAsBigNumberHexString --> TODO should this be encoded using our new 7-bit method? Probably not, right, because it's a single number and will already be efficiently binary-encoded?
     *
     * @generated from field: bytes proposed_payment_payment_mode_logical_asset_amount = 4;
     */
    value: Uint8Array;
    case: "proposedPaymentPaymentModeLogicalAssetAmount";
  } | {
    /**
     * If oneof is this option, then this checkout is using "pay what you want" mode, which allows the sender to pay what they want within the constraints of these PayWhatYouWant details. Deserialized as CheckoutSettings.proposedPayment.paymentMode.payWhatYouWant
     *
     * @generated from field: threecities.v1.CheckoutSettings.PayWhatYouWant proposed_payment_payment_mode_pay_what_you_want = 5;
     */
    value: CheckoutSettings_PayWhatYouWant;
    case: "proposedPaymentPaymentModePayWhatYouWant";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * optional. See comparative analysis below for why this design was chosen
   *
   * @generated from oneof threecities.v1.CheckoutSettings.receiver_strategy_preferences_accepted_token_tickers
   */
  receiverStrategyPreferencesAcceptedTokenTickers: {
    /**
     * space-delimited list of token tickers in which this checkout's payment must be received. Deserialized as CheckoutSettings.receiverStrategyPreferences.acceptedTokenTickers.allowlist
     *
     * @generated from field: string receiver_strategy_preferences_accepted_token_tickers_allowlist = 6;
     */
    value: string;
    case: "receiverStrategyPreferencesAcceptedTokenTickersAllowlist";
  } | {
    /**
     * space-delimited list of token tickers in which this checkout's payment must not be received. Deserialized as CheckoutSettings.receiverStrategyPreferences.acceptedTokenTickers.denylist
     *
     * @generated from field: string receiver_strategy_preferences_accepted_token_tickers_denylist = 7;
     */
    value: string;
    case: "receiverStrategyPreferencesAcceptedTokenTickersDenylist";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * optional. See comparative analysis below for why this design was chosen --> TODO I think the generated links will almost always be shorter if we serialize the chainIds as space-delimited strings
   *
   * @generated from oneof threecities.v1.CheckoutSettings.receiver_strategy_preferences_accepted_chain_ids
   */
  receiverStrategyPreferencesAcceptedChainIds: {
    /**
     * byte-packed array of big-endian uint32 chain ids on which this checkout's payment must be received. Deserialized as CheckoutSettings.receiverStrategyPreferences.acceptedChainIds.allowlist
     *
     * @generated from field: bytes receiver_strategy_preferences_accepted_chain_ids_allowlist = 8;
     */
    value: Uint8Array;
    case: "receiverStrategyPreferencesAcceptedChainIdsAllowlist";
  } | {
    /**
     * byte-packed array of big-endian uint32 chain ids on which this checkout's payment must not be received. Deserialized as CheckoutSettings.receiverStrategyPreferences.acceptedChainIds.denylist
     *
     * @generated from field: bytes receiver_strategy_preferences_accepted_chain_ids_denylist = 9;
     */
    value: Uint8Array;
    case: "receiverStrategyPreferencesAcceptedChainIdsDenylist";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * optional. Human-readable note describing or contextualizing this checkout, intended to be read by the sender. Deserialized as CheckoutSettings.note
   *
   * @generated from field: string note = 10;
   */
  note = "";

  /**
   * optional. Specifies whether the sender/buyer may optionally or must provide a note to the receiver/seller. If omitted, then sender may not provide a note. Deserialized as CheckoutSettings.senderNoteSettings.mode
   *
   * @generated from field: threecities.v1.CheckoutSettings.SenderNoteSettingsMode sender_note_settings_mode = 16;
   */
  senderNoteSettingsMode = CheckoutSettings_SenderNoteSettingsMode.UNSPECIFIED;

  /**
   * optional if sender_note_settings_mode is non-empty (ie. optional iff mode is 'optional' or 'required'). Must be omitted if sender_note_settings_mode is omitted (ie. must be omitted iff mode is 'none'). Human-readable instructions for sender/buyer as to what sender note may/must be provided. Eg. "Please enter your full name". Deserialized as CheckoutSettings.senderNoteSettings.instructions
   *
   * @generated from field: string sender_note_settings_instructions = 17;
   */
  senderNoteSettingsInstructions = "";

  /**
   * optional. URL to redirect to after successful checkout. If this URL begins with a tilde "~", the redirect will be opened in a new tab. Deserialized as CheckoutSettings.successRedirect
   *
   * @generated from field: string success_redirect_url = 18;
   */
  successRedirectUrl = "";

  /**
   * optional. Webhook URL to call when checkout events occur, eg. on checkout success. Deserialized as CheckoutSettings.webhookUrl
   *
   * @generated from field: string webhook_url = 19;
   */
  webhookUrl = "";

  constructor(data?: PartialMessage<CheckoutSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "threecities.v1.CheckoutSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposed_payment_receiver_address", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "proposed_payment_receiver" },
    { no: 2, name: "proposed_payment_receiver_ens_name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "proposed_payment_receiver" },
    { no: 3, name: "proposed_payment_logical_asset_ticker", kind: "enum", T: proto3.getEnumType(LogicalAssetTicker) },
    { no: 4, name: "proposed_payment_payment_mode_logical_asset_amount", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "proposed_payment_payment_mode" },
    { no: 5, name: "proposed_payment_payment_mode_pay_what_you_want", kind: "message", T: CheckoutSettings_PayWhatYouWant, oneof: "proposed_payment_payment_mode" },
    { no: 6, name: "receiver_strategy_preferences_accepted_token_tickers_allowlist", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "receiver_strategy_preferences_accepted_token_tickers" },
    { no: 7, name: "receiver_strategy_preferences_accepted_token_tickers_denylist", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "receiver_strategy_preferences_accepted_token_tickers" },
    { no: 8, name: "receiver_strategy_preferences_accepted_chain_ids_allowlist", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "receiver_strategy_preferences_accepted_chain_ids" },
    { no: 9, name: "receiver_strategy_preferences_accepted_chain_ids_denylist", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "receiver_strategy_preferences_accepted_chain_ids" },
    { no: 10, name: "note", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "sender_note_settings_mode", kind: "enum", T: proto3.getEnumType(CheckoutSettings_SenderNoteSettingsMode) },
    { no: 17, name: "sender_note_settings_instructions", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "success_redirect_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "webhook_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSettings {
    return new CheckoutSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSettings {
    return new CheckoutSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSettings {
    return new CheckoutSettings().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSettings | PlainMessage<CheckoutSettings> | undefined, b: CheckoutSettings | PlainMessage<CheckoutSettings> | undefined): boolean {
    return proto3.util.equals(CheckoutSettings, a, b);
  }
}

/**
 * SenderNoteSettingsMode determines whether the sender/buyer may not
 * provide a note (ie. when this enum is omitted), may provide a note
 * (optional mode), or must provide a note (required mode).
 *
 * @generated from enum threecities.v1.CheckoutSettings.SenderNoteSettingsMode
 */
export enum CheckoutSettings_SenderNoteSettingsMode {
  /**
   * @generated from enum value: SENDER_NOTE_SETTINGS_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * NB we omit the case where mode is "none" because by
   * convention, we indicate this case by by omitting this enum
   * value during serialization, and during deserialization,
   * assuming that the zero value of UNSPECIFIED implies mode is
   * "none". This saves 2 bytes in the binary serialization when
   * mode is "none" which is expected to be the modal case.
   *
   * @generated from enum value: SENDER_NOTE_SETTINGS_MODE_OPTIONAL = 1;
   */
  OPTIONAL = 1,

  /**
   * @generated from enum value: SENDER_NOTE_SETTINGS_MODE_REQUIRED = 2;
   */
  REQUIRED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckoutSettings_SenderNoteSettingsMode)
proto3.util.setEnumType(CheckoutSettings_SenderNoteSettingsMode, "threecities.v1.CheckoutSettings.SenderNoteSettingsMode", [
  { no: 0, name: "SENDER_NOTE_SETTINGS_MODE_UNSPECIFIED" },
  { no: 1, name: "SENDER_NOTE_SETTINGS_MODE_OPTIONAL" },
  { no: 2, name: "SENDER_NOTE_SETTINGS_MODE_REQUIRED" },
]);

/**
 * @generated from message threecities.v1.CheckoutSettings.PayWhatYouWant
 */
export class CheckoutSettings_PayWhatYouWant extends Message<CheckoutSettings_PayWhatYouWant> {
  /**
   * required iff any flag is true, otherwise must be omitted iff all flags are false. See note on PayWhatYouWantFlags. Deserialized into multiple booleans inside CheckoutSettings.proposedPayment.paymentMode.payWhatYouWant
   *
   * @generated from field: threecities.v1.CheckoutSettings.PayWhatYouWant.PayWhatYouWantFlags flags = 1;
   */
  flags = CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags.UNSPECIFIED;

  /**
   * optional. Big-endian binary encoding of suggested payment logical asset amounts. Since this is "pay what you want" mode, these amounts are only suggested to the sender and not required. Deserialized as CheckoutSettings.proposedPayment.paymentMode.payWhatYouWant.suggestedLogicalAssetAmountsAsBigNumberHexStrings --> TODO should this be encoded using our new 7-bit method (as a `bytes` instead of `repeated bytes`? I think so?
   *
   * @generated from field: repeated bytes suggested_logical_asset_amounts = 2;
   */
  suggestedLogicalAssetAmounts: Uint8Array[] = [];

  constructor(data?: PartialMessage<CheckoutSettings_PayWhatYouWant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "threecities.v1.CheckoutSettings.PayWhatYouWant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "flags", kind: "enum", T: proto3.getEnumType(CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags) },
    { no: 2, name: "suggested_logical_asset_amounts", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSettings_PayWhatYouWant {
    return new CheckoutSettings_PayWhatYouWant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSettings_PayWhatYouWant {
    return new CheckoutSettings_PayWhatYouWant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSettings_PayWhatYouWant {
    return new CheckoutSettings_PayWhatYouWant().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSettings_PayWhatYouWant | PlainMessage<CheckoutSettings_PayWhatYouWant> | undefined, b: CheckoutSettings_PayWhatYouWant | PlainMessage<CheckoutSettings_PayWhatYouWant> | undefined): boolean {
    return proto3.util.equals(CheckoutSettings_PayWhatYouWant, a, b);
  }
}

/**
 * PayWhatYouWantFlags is an enum used to bitpack a set of boolean
 * flags used in PayWhatYouWant into the smaller enum type. The set
 * of flags are: 1) isDynamicPricingEnabled is true iff 3cities
 * should try to suggest different amounts to pay based on the net
 * worth of the sender's connected wallet (eg. rich wallets get
 * suggested to pay more), 2) canDonateAnyAsset is true iff the
 * sender may donate any token in any amount, bypassing the usual
 * need to pay in the receiver's specified logical asset. Using this
 * enum to bitpack makes these flags consume a total of 2 bytes if
 * any flags are set or 0 bytes if none are set. Using regular bools
 * consumes 2 bytes per bool. Up to 6 flags can be included in this
 * enum without widening it from 2 bytes to 3 bytes because any
 * value from 0 to 127 (2^7) takes only 2 bytes, but we reserve 0
 * for unspecified, and so we can only fit 6 flags because we need
 * 128 values to fit a full 7 but we have only 127 values since 0 is
 * reserved.
 *
 * @generated from enum threecities.v1.CheckoutSettings.PayWhatYouWant.PayWhatYouWantFlags
 */
export enum CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags {
  /**
   * @generated from enum value: PAY_WHAT_YOU_WANT_FLAGS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * NB we omit the case where all flags are false because by
   * convention, we indicate this case by by omitting this enum
   * value during serialization, and during deserialization,
   * assuming that the zero value of UNSPECIFIED implies no flags
   * are set. This saves 2 bytes in the binary serialization when no
   * flags are set.
   *
   * @generated from enum value: PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_FALSE_CAN_DONATE_ANY_ASSET_TRUE = 1;
   */
  IS_DYNAMIC_PRICING_ENABLED_FALSE_CAN_DONATE_ANY_ASSET_TRUE = 1,

  /**
   * @generated from enum value: PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_DONATE_ANY_ASSET_FALSE = 2;
   */
  IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_DONATE_ANY_ASSET_FALSE = 2,

  /**
   * @generated from enum value: PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_DONATE_ANY_ASSET_TRUE = 3;
   */
  IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_DONATE_ANY_ASSET_TRUE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags)
proto3.util.setEnumType(CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags, "threecities.v1.CheckoutSettings.PayWhatYouWant.PayWhatYouWantFlags", [
  { no: 0, name: "PAY_WHAT_YOU_WANT_FLAGS_UNSPECIFIED" },
  { no: 1, name: "PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_FALSE_CAN_DONATE_ANY_ASSET_TRUE" },
  { no: 2, name: "PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_DONATE_ANY_ASSET_FALSE" },
  { no: 3, name: "PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_DONATE_ANY_ASSET_TRUE" },
]);

/**
 * CheckoutSettingsSigned is an envelope for a cryptographically signed
 * CheckoutSettings to help prevent phishing attempts. WARNING
 * signatures protect only against modifications to the CheckoutSettings
 * and not against the 3cities app being phished.
 *
 * @generated from message threecities.v1.CheckoutSettingsSigned
 */
export class CheckoutSettingsSigned extends Message<CheckoutSettingsSigned> {
  /**
   * required. The CheckoutSettings that has been cryptographically signed
   *
   * @generated from field: threecities.v1.CheckoutSettings checkout_settings = 1;
   */
  checkoutSettings?: CheckoutSettings;

  /**
   * required. The cryptographic signature and salt that, together with a password (held separately), are needed to verify the signature and ensure the CheckoutSettings has not been modified (eg. by a phishing attempt)
   *
   * @generated from field: uint64 signature_and_salt = 2;
   */
  signatureAndSalt = protoInt64.zero;

  constructor(data?: PartialMessage<CheckoutSettingsSigned>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "threecities.v1.CheckoutSettingsSigned";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkout_settings", kind: "message", T: CheckoutSettings },
    { no: 2, name: "signature_and_salt", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSettingsSigned {
    return new CheckoutSettingsSigned().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSettingsSigned {
    return new CheckoutSettingsSigned().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSettingsSigned {
    return new CheckoutSettingsSigned().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSettingsSigned | PlainMessage<CheckoutSettingsSigned> | undefined, b: CheckoutSettingsSigned | PlainMessage<CheckoutSettingsSigned> | undefined): boolean {
    return proto3.util.equals(CheckoutSettingsSigned, a, b);
  }
}

/**
 * CheckoutSettingsEncrypted is an envelope for an encrypted
 * CheckoutSettings to make the contents of shareable links private and
 * help prevent phishing attempts. WARNING encryption protects only
 * against public viewing of and modifications to the CheckoutSettings
 * and not against the 3cities app being phished.
 *
 * @generated from message threecities.v1.CheckoutSettingsEncrypted
 */
export class CheckoutSettingsEncrypted extends Message<CheckoutSettingsEncrypted> {
  /**
   * required. The CheckoutSettings that has been encrypted
   *
   * @generated from field: bytes encrypted_checkout_settings = 1;
   */
  encryptedCheckoutSettings = new Uint8Array(0);

  /**
   * required. The cryptographic salt and iv that, together with a password (held separately), are needed to decrypt the CheckoutSettings
   *
   * @generated from field: uint64 salt_and_iv = 2;
   */
  saltAndIv = protoInt64.zero;

  constructor(data?: PartialMessage<CheckoutSettingsEncrypted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "threecities.v1.CheckoutSettingsEncrypted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encrypted_checkout_settings", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "salt_and_iv", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSettingsEncrypted {
    return new CheckoutSettingsEncrypted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSettingsEncrypted {
    return new CheckoutSettingsEncrypted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSettingsEncrypted {
    return new CheckoutSettingsEncrypted().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSettingsEncrypted | PlainMessage<CheckoutSettingsEncrypted> | undefined, b: CheckoutSettingsEncrypted | PlainMessage<CheckoutSettingsEncrypted> | undefined): boolean {
    return proto3.util.equals(CheckoutSettingsEncrypted, a, b);
  }
}

