// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file threecities/v1/v1.proto (package threecities.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * LogicalAssetTicker is the set of all logical asset tickers we
 * support. Our app-layer LogicalAssetTicker types are automatically
 * derived from this single authoritative definition in a typesafe
 * manner.
 *
 * @generated from enum threecities.v1.LogicalAssetTicker
 */
export enum LogicalAssetTicker {
  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_ETH = 1;
   */
  ETH = 1,

  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_USD = 2;
   */
  USD = 2,

  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_EUR = 3;
   */
  EUR = 3,

  /**
   * @generated from enum value: LOGICAL_ASSET_TICKER_CAD = 4;
   */
  CAD = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(LogicalAssetTicker)
proto3.util.setEnumType(LogicalAssetTicker, "threecities.v1.LogicalAssetTicker", [
  { no: 0, name: "LOGICAL_ASSET_TICKER_UNSPECIFIED" },
  { no: 1, name: "LOGICAL_ASSET_TICKER_ETH" },
  { no: 2, name: "LOGICAL_ASSET_TICKER_USD" },
  { no: 3, name: "LOGICAL_ASSET_TICKER_EUR" },
  { no: 4, name: "LOGICAL_ASSET_TICKER_CAD" },
]);

/**
 * MessageType is an enum to help clients differentiate between
 * top-level message types given an anonymous binary message
 * serialization. CheckoutSettings, as by far the most popular message
 * type, omits MessageType to reduce binary serialization size, and so
 * binary serializations are of type CheckoutSettings iff they omit a
 * MessageType field, which must always use field number 2047. Ie.
 * `MessageType message_type = 2047;` must appear in all top-level
 * message types except CheckoutSettings. Field number 2047 chosen as
 * it's the largest field number whose tag has a 2-byte overhead. Only
 * field numbers <=15 have a 1-byte overhead, so we don't want to
 * reserve one of those scarce fields for this type.
 *
 * @generated from enum threecities.v1.MessageType
 */
export enum MessageType {
  /**
   * @generated from enum value: MESSAGE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MESSAGE_TYPE_CHECKOUT_SETTINGS_SIGNED = 1;
   */
  CHECKOUT_SETTINGS_SIGNED = 1,

  /**
   * @generated from enum value: MESSAGE_TYPE_CHECKOUT_SETTINGS_ENCRYPTED = 2;
   */
  CHECKOUT_SETTINGS_ENCRYPTED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(MessageType)
proto3.util.setEnumType(MessageType, "threecities.v1.MessageType", [
  { no: 0, name: "MESSAGE_TYPE_UNSPECIFIED" },
  { no: 1, name: "MESSAGE_TYPE_CHECKOUT_SETTINGS_SIGNED" },
  { no: 2, name: "MESSAGE_TYPE_CHECKOUT_SETTINGS_ENCRYPTED" },
]);

/**
 * CheckoutSettings is a flattened variant of our app-layer type
 * CheckoutSettings. This CheckoutSettings has been flattened into a
 * single type (ie. instead of using separate types for proposedPayment,
 * etc) to help minimize binary serialization message size.
 *
 * @generated from message threecities.v1.CheckoutSettings
 */
export class CheckoutSettings extends Message<CheckoutSettings> {
  /**
   * required. CheckoutSettings protobuf message major version. Must be set to 1 for all CheckoutSettings created from this protobuf package. Ie. this package is threecities.v1, corresponding to checkoutSettingsMajorVersion set to 1. checkout_settings_major_version helps clients differentiate between different CheckoutSettings major versions given an anonymous binary message serialization which is otherwise known to be a CheckoutSettings
   *
   * @generated from field: uint32 checkout_settings_major_version = 1;
   */
  checkoutSettingsMajorVersion = 0;

  /**
   * required.
   *
   * @generated from oneof threecities.v1.CheckoutSettings.proposed_payment_receiver
   */
  proposedPaymentReceiver: {
    /**
     * Big-endian binary encoding of Ethereum address of the payment receiver. Deserialized as CheckoutSettings.proposedPayment.receiver.address
     *
     * @generated from field: bytes proposed_payment_receiver_address = 2;
     */
    value: Uint8Array;
    case: "proposedPaymentReceiverAddress";
  } | {
    /**
     * ENS name of the payment receiver. Deserialized as CheckoutSettings.proposedPayment.receiver.ensName
     *
     * @generated from field: string proposed_payment_receiver_ens_name = 3;
     */
    value: string;
    case: "proposedPaymentReceiverEnsName";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * required. The first element is the required ticker for the primary logical asset in which the payment is denominated. Other elements are the optional prioritized secondary logical assets that are also accepted for payment. Eg. the 2nd element is a higher priority secondary logical asset than the 3rd element. Deserialized as CheckoutSettings.proposedPayment.logicalAssetTickers
   *
   * @generated from field: repeated threecities.v1.LogicalAssetTicker proposed_payment_logical_asset_tickers = 4;
   */
  proposedPaymentLogicalAssetTickers: LogicalAssetTicker[] = [];

  /**
   * required.
   *
   * @generated from oneof threecities.v1.CheckoutSettings.proposed_payment_payment_mode
   */
  proposedPaymentPaymentMode: {
    /**
     * Big-endian binary encoding of payment logical asset amount. Deserialized as CheckoutSettings.proposedPayment.paymentMode.logicalAssetAmountAsBigNumberHexString
     *
     * @generated from field: bytes proposed_payment_payment_mode_logical_asset_amount = 5;
     */
    value: Uint8Array;
    case: "proposedPaymentPaymentModeLogicalAssetAmount";
  } | {
    /**
     * If oneof is this option, then this checkout is using "pay what you want" mode, which allows the sender to pay what they want within the constraints of these PayWhatYouWant details. Deserialized as CheckoutSettings.proposedPayment.paymentMode.payWhatYouWant
     *
     * @generated from field: threecities.v1.CheckoutSettings.PayWhatYouWant proposed_payment_payment_mode_pay_what_you_want = 6;
     */
    value: CheckoutSettings_PayWhatYouWant;
    case: "proposedPaymentPaymentModePayWhatYouWant";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * optional. See comparative analysis below for why this design was chosen
   *
   * @generated from oneof threecities.v1.CheckoutSettings.receiver_strategy_preferences_accepted_token_tickers
   */
  receiverStrategyPreferencesAcceptedTokenTickers: {
    /**
     * space-delimited list of token tickers in which this checkout's payment must be received. Deserialized as CheckoutSettings.receiverStrategyPreferences.acceptedTokenTickers.allowlist
     *
     * @generated from field: string receiver_strategy_preferences_accepted_token_tickers_allowlist = 7;
     */
    value: string;
    case: "receiverStrategyPreferencesAcceptedTokenTickersAllowlist";
  } | {
    /**
     * space-delimited list of token tickers in which this checkout's payment must not be received. Deserialized as CheckoutSettings.receiverStrategyPreferences.acceptedTokenTickers.denylist
     *
     * @generated from field: string receiver_strategy_preferences_accepted_token_tickers_denylist = 8;
     */
    value: string;
    case: "receiverStrategyPreferencesAcceptedTokenTickersDenylist";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * optional. See comparative analysis below for why this design was chosen
   *
   * @generated from oneof threecities.v1.CheckoutSettings.receiver_strategy_preferences_accepted_chain_ids
   */
  receiverStrategyPreferencesAcceptedChainIds: {
    /**
     * byte-packed array of big-endian uint32 chain ids on which this checkout's payment must be received. Deserialized as CheckoutSettings.receiverStrategyPreferences.acceptedChainIds.allowlist
     *
     * @generated from field: bytes receiver_strategy_preferences_accepted_chain_ids_allowlist = 9;
     */
    value: Uint8Array;
    case: "receiverStrategyPreferencesAcceptedChainIdsAllowlist";
  } | {
    /**
     * byte-packed array of big-endian uint32 chain ids on which this checkout's payment must not be received. Deserialized as CheckoutSettings.receiverStrategyPreferences.acceptedChainIds.denylist
     *
     * @generated from field: bytes receiver_strategy_preferences_accepted_chain_ids_denylist = 10;
     */
    value: Uint8Array;
    case: "receiverStrategyPreferencesAcceptedChainIdsDenylist";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * optional. Human-readable note describing or contextualizing this checkout, intended to be read by the sender. Deserialized as CheckoutSettings.note
   *
   * @generated from field: string note = 11;
   */
  note = "";

  /**
   * optional. Specifies whether the sender/buyer may optionally or must provide a note to the receiver/seller. If omitted, then sender may not provide a note. Deserialized as CheckoutSettings.senderNoteSettings.mode
   *
   * @generated from field: threecities.v1.CheckoutSettings.SenderNoteSettingsMode sender_note_settings_mode = 16;
   */
  senderNoteSettingsMode = CheckoutSettings_SenderNoteSettingsMode.UNSPECIFIED;

  /**
   * optional if sender_note_settings_mode is non-empty (ie. optional iff mode is 'optional' or 'required'). Must be omitted if sender_note_settings_mode is omitted (ie. must be omitted iff mode is 'none'). Human-readable instructions for sender/buyer as to what sender note may/must be provided. Eg. "Please enter your full name". Deserialized as CheckoutSettings.senderNoteSettings.instructions
   *
   * @generated from field: string sender_note_settings_instructions = 17;
   */
  senderNoteSettingsInstructions = "";

  /**
   * optional. URL to redirect to after successful checkout. If this URL begins with a tilde "~", the redirect will be opened in a new tab. Deserialized as CheckoutSettings.successRedirect.{url,openInNewTab}
   *
   * @generated from field: string success_redirect_url = 18;
   */
  successRedirectUrl = "";

  /**
   * optional if success_redirect_url is non-empty, otherwise must be omitted. Human-readable call to action to prompt the sender/buyer to click a button to trigger the success redirect, as redirects must be triggered by user actions or be suppressed by the browser as spam. Deserialized as CheckoutSettings.successRedirect.callToAction
   *
   * @generated from field: string success_redirect_call_to_action = 19;
   */
  successRedirectCallToAction = "";

  /**
   * optional. Webhook URL to call when checkout events occur, eg. on checkout success. Deserialized as CheckoutSettings.webhookUrl
   *
   * @generated from field: string webhook_url = 20;
   */
  webhookUrl = "";

  constructor(data?: PartialMessage<CheckoutSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "threecities.v1.CheckoutSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkout_settings_major_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "proposed_payment_receiver_address", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "proposed_payment_receiver" },
    { no: 3, name: "proposed_payment_receiver_ens_name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "proposed_payment_receiver" },
    { no: 4, name: "proposed_payment_logical_asset_tickers", kind: "enum", T: proto3.getEnumType(LogicalAssetTicker), repeated: true },
    { no: 5, name: "proposed_payment_payment_mode_logical_asset_amount", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "proposed_payment_payment_mode" },
    { no: 6, name: "proposed_payment_payment_mode_pay_what_you_want", kind: "message", T: CheckoutSettings_PayWhatYouWant, oneof: "proposed_payment_payment_mode" },
    { no: 7, name: "receiver_strategy_preferences_accepted_token_tickers_allowlist", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "receiver_strategy_preferences_accepted_token_tickers" },
    { no: 8, name: "receiver_strategy_preferences_accepted_token_tickers_denylist", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "receiver_strategy_preferences_accepted_token_tickers" },
    { no: 9, name: "receiver_strategy_preferences_accepted_chain_ids_allowlist", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "receiver_strategy_preferences_accepted_chain_ids" },
    { no: 10, name: "receiver_strategy_preferences_accepted_chain_ids_denylist", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "receiver_strategy_preferences_accepted_chain_ids" },
    { no: 11, name: "note", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "sender_note_settings_mode", kind: "enum", T: proto3.getEnumType(CheckoutSettings_SenderNoteSettingsMode) },
    { no: 17, name: "sender_note_settings_instructions", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "success_redirect_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "success_redirect_call_to_action", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "webhook_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSettings {
    return new CheckoutSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSettings {
    return new CheckoutSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSettings {
    return new CheckoutSettings().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSettings | PlainMessage<CheckoutSettings> | undefined, b: CheckoutSettings | PlainMessage<CheckoutSettings> | undefined): boolean {
    return proto3.util.equals(CheckoutSettings, a, b);
  }
}

/**
 * SenderNoteSettingsMode determines whether the sender/buyer may not
 * provide a note (ie. when this enum is omitted), may provide a note
 * (optional mode), or must provide a note (required mode).
 *
 * @generated from enum threecities.v1.CheckoutSettings.SenderNoteSettingsMode
 */
export enum CheckoutSettings_SenderNoteSettingsMode {
  /**
   * @generated from enum value: SENDER_NOTE_SETTINGS_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * NB we omit the case where mode is "none" because by convention,
   * we indicate this case by by omitting this enum value during
   * serialization, and during deserialization, assuming that the zero
   * value of UNSPECIFIED implies mode is "none". This saves 2 bytes
   * in the binary serialization when mode is "none" which is expected
   * to be the modal case.
   *
   * @generated from enum value: SENDER_NOTE_SETTINGS_MODE_OPTIONAL = 1;
   */
  OPTIONAL = 1,

  /**
   * @generated from enum value: SENDER_NOTE_SETTINGS_MODE_REQUIRED = 2;
   */
  REQUIRED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckoutSettings_SenderNoteSettingsMode)
proto3.util.setEnumType(CheckoutSettings_SenderNoteSettingsMode, "threecities.v1.CheckoutSettings.SenderNoteSettingsMode", [
  { no: 0, name: "SENDER_NOTE_SETTINGS_MODE_UNSPECIFIED" },
  { no: 1, name: "SENDER_NOTE_SETTINGS_MODE_OPTIONAL" },
  { no: 2, name: "SENDER_NOTE_SETTINGS_MODE_REQUIRED" },
]);

/**
 * @generated from message threecities.v1.CheckoutSettings.PayWhatYouWant
 */
export class CheckoutSettings_PayWhatYouWant extends Message<CheckoutSettings_PayWhatYouWant> {
  /**
   * required iff any flag is true, otherwise must be omitted iff all flags are false. See note on PayWhatYouWantFlags. Deserialized into multiple booleans inside CheckoutSettings.proposedPayment.paymentMode.payWhatYouWant
   *
   * @generated from field: threecities.v1.CheckoutSettings.PayWhatYouWant.PayWhatYouWantFlags flags = 1;
   */
  flags = CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags.UNSPECIFIED;

  /**
   * optional. Big-endian binary encoding of suggested payment logical asset amounts. Since this is "pay what you want" mode, these amounts are only suggested to the sender and not required. Deserialized as CheckoutSettings.proposedPayment.paymentMode.payWhatYouWant.suggestedLogicalAssetAmountsAsBigNumberHexStrings
   *
   * @generated from field: repeated bytes suggested_logical_asset_amounts = 2;
   */
  suggestedLogicalAssetAmounts: Uint8Array[] = [];

  constructor(data?: PartialMessage<CheckoutSettings_PayWhatYouWant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "threecities.v1.CheckoutSettings.PayWhatYouWant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "flags", kind: "enum", T: proto3.getEnumType(CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags) },
    { no: 2, name: "suggested_logical_asset_amounts", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSettings_PayWhatYouWant {
    return new CheckoutSettings_PayWhatYouWant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSettings_PayWhatYouWant {
    return new CheckoutSettings_PayWhatYouWant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSettings_PayWhatYouWant {
    return new CheckoutSettings_PayWhatYouWant().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSettings_PayWhatYouWant | PlainMessage<CheckoutSettings_PayWhatYouWant> | undefined, b: CheckoutSettings_PayWhatYouWant | PlainMessage<CheckoutSettings_PayWhatYouWant> | undefined): boolean {
    return proto3.util.equals(CheckoutSettings_PayWhatYouWant, a, b);
  }
}

/**
 * PayWhatYouWantFlags is an enum used to bitpack a set of boolean
 * flags used in PayWhatYouWant into the smaller enum type. The set
 * of flags are: 1) isDynamicPricingEnabled is true iff 3cities
 * should try to suggest different amounts to pay based on the net
 * worth of the sender's connected wallet (eg. rich wallets get
 * suggested to pay more), 2) canPayAnyAsset is true iff the sender
 * may pay any token in any amount, bypassing the usual need to pay
 * in the receiver's specified logical asset. Using this enum to
 * bitpack makes these flags consume a total of 2 bytes if any flags
 * are set or 0 bytes if none are set. Using regular bools consumes
 * 2 bytes per bool. Up to 6 flags can be included in this enum
 * without widening it from 2 bytes to 3 bytes because any value
 * from 0 to 127 (2^7) takes only 2 bytes, but we reserve 0 for
 * unspecified, and so we can only fit 6 flags because we need 128
 * values to fit a full 7 but we have only 127 values since 0 is
 * reserved.
 *
 * @generated from enum threecities.v1.CheckoutSettings.PayWhatYouWant.PayWhatYouWantFlags
 */
export enum CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags {
  /**
   * @generated from enum value: PAY_WHAT_YOU_WANT_FLAGS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * NB we omit the case where all flags are false because by
   * convention, we indicate this case by by omitting this enum
   * value during serialization, and during deserialization,
   * assuming that the zero value of UNSPECIFIED implies no flags
   * are set. This saves 2 bytes in the binary serialization when no
   * flags are set.
   *
   * @generated from enum value: PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_FALSE_CAN_PAY_ANY_ASSET_TRUE = 1;
   */
  IS_DYNAMIC_PRICING_ENABLED_FALSE_CAN_PAY_ANY_ASSET_TRUE = 1,

  /**
   * @generated from enum value: PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_PAY_ANY_ASSET_FALSE = 2;
   */
  IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_PAY_ANY_ASSET_FALSE = 2,

  /**
   * @generated from enum value: PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_PAY_ANY_ASSET_TRUE = 3;
   */
  IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_PAY_ANY_ASSET_TRUE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags)
proto3.util.setEnumType(CheckoutSettings_PayWhatYouWant_PayWhatYouWantFlags, "threecities.v1.CheckoutSettings.PayWhatYouWant.PayWhatYouWantFlags", [
  { no: 0, name: "PAY_WHAT_YOU_WANT_FLAGS_UNSPECIFIED" },
  { no: 1, name: "PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_FALSE_CAN_PAY_ANY_ASSET_TRUE" },
  { no: 2, name: "PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_PAY_ANY_ASSET_FALSE" },
  { no: 3, name: "PAY_WHAT_YOU_WANT_FLAGS_IS_DYNAMIC_PRICING_ENABLED_TRUE_CAN_PAY_ANY_ASSET_TRUE" },
]);

/**
 * CheckoutSettingsSigned is an envelope for a cryptographically signed
 * CheckoutSettings to help prevent phishing attempts. WARNING
 * signatures protect only against modifications to the CheckoutSettings
 * and not against the 3cities app being phished.
 *
 * @generated from message threecities.v1.CheckoutSettingsSigned
 */
export class CheckoutSettingsSigned extends Message<CheckoutSettingsSigned> {
  /**
   * required. The CheckoutSettings that has been cryptographically signed
   *
   * @generated from field: threecities.v1.CheckoutSettings checkout_settings = 1;
   */
  checkoutSettings?: CheckoutSettings;

  /**
   * required. The cryptographic salt that, together with the signature (in this message) and a password (held separately), are needed to verify the signature and ensure the CheckoutSettings has not been modified (eg. by a phishing attempt)
   *
   * @generated from field: bytes salt = 2;
   */
  salt = new Uint8Array(0);

  /**
   * required. The cryptographic signature, together with the salt (in this message) a password (held separately), are needed to verify the signature and ensure the CheckoutSettings has not been modified (eg. by a phishing attempt)
   *
   * @generated from field: bytes signature = 3;
   */
  signature = new Uint8Array(0);

  /**
   * required. Must be set to MESSAGE_TYPE_CHECKOUT_SETTINGS_SIGNED. See note on MessageType
   *
   * @generated from field: threecities.v1.MessageType message_type = 2047;
   */
  messageType = MessageType.UNSPECIFIED;

  constructor(data?: PartialMessage<CheckoutSettingsSigned>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "threecities.v1.CheckoutSettingsSigned";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checkout_settings", kind: "message", T: CheckoutSettings },
    { no: 2, name: "salt", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2047, name: "message_type", kind: "enum", T: proto3.getEnumType(MessageType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSettingsSigned {
    return new CheckoutSettingsSigned().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSettingsSigned {
    return new CheckoutSettingsSigned().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSettingsSigned {
    return new CheckoutSettingsSigned().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSettingsSigned | PlainMessage<CheckoutSettingsSigned> | undefined, b: CheckoutSettingsSigned | PlainMessage<CheckoutSettingsSigned> | undefined): boolean {
    return proto3.util.equals(CheckoutSettingsSigned, a, b);
  }
}

/**
 * CheckoutSettingsEncrypted is an envelope for an encrypted
 * CheckoutSettings to make the contents of shareable links private and
 * help prevent phishing attempts. WARNING encryption protects only
 * against public viewing of and modifications to the CheckoutSettings
 * and not against the 3cities app being phished.
 *
 * @generated from message threecities.v1.CheckoutSettingsEncrypted
 */
export class CheckoutSettingsEncrypted extends Message<CheckoutSettingsEncrypted> {
  /**
   * required. The CheckoutSettings that has been encrypted
   *
   * @generated from field: bytes encrypted_checkout_settings = 1;
   */
  encryptedCheckoutSettings = new Uint8Array(0);

  /**
   * required. The cryptographic salt that, together with the iv (in this message) and a password (held separately), are needed to decrypt the CheckoutSettings
   *
   * @generated from field: bytes salt = 2;
   */
  salt = new Uint8Array(0);

  /**
   * required. The cryptographic iv that, together with the salt (in this message) and a password (held separately), are needed to decrypt the CheckoutSettings
   *
   * @generated from field: bytes iv = 3;
   */
  iv = new Uint8Array(0);

  /**
   * required. Must be set to MESSAGE_TYPE_CHECKOUT_SETTINGS_ENCRYPTED. See note on MessageType
   *
   * @generated from field: threecities.v1.MessageType message_type = 2047;
   */
  messageType = MessageType.UNSPECIFIED;

  constructor(data?: PartialMessage<CheckoutSettingsEncrypted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "threecities.v1.CheckoutSettingsEncrypted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encrypted_checkout_settings", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "salt", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "iv", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2047, name: "message_type", kind: "enum", T: proto3.getEnumType(MessageType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSettingsEncrypted {
    return new CheckoutSettingsEncrypted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSettingsEncrypted {
    return new CheckoutSettingsEncrypted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSettingsEncrypted {
    return new CheckoutSettingsEncrypted().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSettingsEncrypted | PlainMessage<CheckoutSettingsEncrypted> | undefined, b: CheckoutSettingsEncrypted | PlainMessage<CheckoutSettingsEncrypted> | undefined): boolean {
    return proto3.util.equals(CheckoutSettingsEncrypted, a, b);
  }
}

