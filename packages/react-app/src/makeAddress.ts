import { Address } from 'wagmi';

// makeAddress: TODO HACK here we assume that every string is of type `0x$s` to coerce our string addresses into wagmi's Address type --> what are the design options here? option 1) use wagmi's Address type everywhere (high coupling... although wagmi will be used everywhere in codebase, there's a difference between relying it on heavily but in an abstracted/wrapped way vs. using their types in our core data structures), option 2) write our own address type (but if they update theirs, we'll have to update manually), option 3) use strings in our codebase and do runtime narrowing every time we pass to wagmi --> this can fail at runtime but in practice would never fail --> is there a 4th option? not sure which of these to pick, what are the tradeoffs? "All decisions are subject to tradeoffs. Itâ€™s more important to know what the decision depends on than it is to know which answer to pick today (or which answer you picked yesterday)." --> two other tradeoffs: it looks like wagmi itself may have introduced the Address type to help avoid ppl accidentally passing ens names where only addresses are supported, that sounds useful to me, too; and, what about when 3cities adds a non-evm chain with addresses that don't start with 0x? I'm going to have to do a big refactor to support the first non-evm chain, and that might be easier if the entire codebase isn't littered with interior/core dependencies on 0x addresses --> relevant: https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/ "Push the burden of proof upward as far as possible, but no further. Get your data into the most precise representation you need as quickly as you can. Ideally, this should happen at the boundary of your system, before any of the data is acted upon... If one particular code branch eventually requires a more precise representation of a piece of data, parse the data into the more precise representation as soon as the branch is selected. Use sum types judiciously to allow your datatypes to reflect and adapt to control flow." --> yet, not sure that I agree with this here, I think I might rather cast to Address as close to wagmi as possible and throw runtime errors if the cast fails because that keeps our addresses basic strings to be serializable (and can't ENS names begin with '0x'? and why else? needs further thought and to enumerate tradeoffs)
export function makeAddress(s: string): Address {
  if (s.startsWith('0x') && tempIsAddress(s)) return s;
  else throw new Error(`makeAddress: invalid address ${s}`);
  function tempIsAddress(s2: string): s2 is Address {
    return s2 ? true : true; // satisfy the linter that s2 isn't an unused variable
  }
}
